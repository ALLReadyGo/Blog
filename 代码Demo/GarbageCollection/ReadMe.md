# 垃圾回收算法实现

在CPP环境下实现了垃圾回收

#### 内存引用图构建

对于垃圾回收算法，其关键点在于构建内存引用图。当我们需要释放内存时便会遍历内存引用图，图中所有不可达点都为待释放内存。

为了实现这个目的我们需要两个关键结构`gc_ptr`和`GCHandle`.`gc_ptr`为指向GC对象的指针，`GCHandle`用于构件内存引用图，可以理解为图中的各个节点。

我们知道指针可以在三个区域存在静态区、栈区和动态内存区。静态区和栈区的指针我们都可以获取到，而动态内存区的指针必须由前两个区域的指针间接获取。所以图的起点便是这些分配于静态区和栈区的指针。

其进行的具体操作如下

> `GCHandle`中有两个关键元素`int count` 和 `std::set<GCHandle*> reference`。
> 当GC对象A内存中gc_ptr指向GC对象B时，其操作为A'GCHandle.reference 添加 B'GCHandle
> 当gc_ptr位于栈或者静态区时指向GC对象A，A'GCHandle.count++

当GCHandle.count > 0 时表示其存在栈指针对其进行指向，
GCHandle.reference 存在的元素表示其表示的GC对象内部存在gc_ptr，其指向了另一个GC对象。

#### 内存析构

除了需要回收分配的内存之外，我们还需要对内存指向的实际对象进行析构。为实现此目的，我们需要将每个GC对象都指定一个统一的派生类GCBase，并将析构函数设置为虚函数。这样当我们调用GCBase的析构函数时便会实际调用其内存所对应的对象的析构函数。

其中由于对象内存结构的问题，我们无法将(void \*)转化为(GCBase\*)，所以我们还需要额外存储GCBase\*。

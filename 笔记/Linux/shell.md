---
title: shell
categories: Linux
tags:
 - Linux
---

## shell

#### shell是什么

shell是一种应用程序，其提供了一种接口让我们能够与系统进行交互。日常使用中例如打开某个文件、利用软件发送Email这些行为，都是我们利用shell+应用程序完成的。在Linux操作系统底层，其支持一个进程exec任何一个executable程序，shell便是这样的程序。当我们想执行某个程序时，shell进程便会fork自身，创建一个新的进程然后执行我们在命令行输入的命令。此创建的新进程和shell之间是父子进程关系。

#### shell的基本命令格式

`command [-option] [parameter]`

根据fork + exec执行流程，我们如果想要执行某个应用程序，其首要的工作必须明确指定exec程序所在的位置，所以对于command我们必须明确指出他所在的文件系统路径，指出文件所在位置最简单的办法就是写出文件的绝对路径。但是这种方式存在一个很大的问题，就是每次执行程序都需要写很长的一段去明确指明命令位置，因此PATH环境变量便是对这一问题的解决办法。我们不必每次给出完整路径，而是只用给出一个命令名便可以正确执行程序。但是这种方法并不一定保证没有问题，如果搜索路径中出现同名程序，那么shell将使用哪个呢？其会调用匹配到的第一个程序。这样的调用策略在某些情况下可能会让我们执行某些意想不到的程序。

`[-option] [parameter]` 实质上是一种东西，我们在学习C程序时会学到如下main函数表达方式

```c
int main(int argc, char const *argv[])
{
    /* code */
    return 0;
}
```

其中的各种意义不必多说，这里只是想表达在程序执行前，可以传递参数是操作系统提供的功能，但是操作系统并不区分每个字段的类型和意义。也就是说，传递的任何参数操作系统都会将他们当作字符串进行存储传递。我们所传递的`[option]` `[parameter]`在系统看来都是字符串而已，解析的工作是由应用程序完成的。

#### shell命令与函数的关系与区别

依据上面的解析，shell命令与函数可以说从概念上一致。他们都代表一组执行流程，并且在调用过程中都可以传递参数来改变其行为。但是与C语言函数不同的是，其在调用方面有如下特点。注意其只在调用方式上不同而已，从作用的功能的逻辑出发他们是一致。

* shell参数没有明显的顺序要求

  在C语言中参数必须严格按照一定顺序进行传递，并且不能出现缺失，这样的调用方式便导致缺省参数的使用非常ugly。shell想更好的利用缺省参数，每次调用时不必将参数全部指定。这里想想python是怎么做的，他是利用`变量名=value`来实现这个的。而shell则使用如下逻辑进行。

  对于**开关参数**，也就是我们常说的bool变量，其使用不要求参数`-p`进行操作。当`-p`出现时开启某个功能，否则则关闭。举例来说`cat -n`将在打印的内容当中标记行号，这便是一种开关选项，因为他只用两个value（开启功能或者关闭功能）

  剩下的参数，可以称为**赋值参数**，我们需要明确传递其值，下列的命令便是其典型代表形式

  `git commit -m 'some information about this commit'`

  **上面提到的并不是强制要求的，这只是命令行程序对于参数解析的惯例，其并没有标准。因为参数的解析是由应用程序进行的**，所以参数的传递还存在如下的形式。重点在于**缺省参数的使用方式和开关参数和赋值参数的区别**

  `who | cut -c1-4`

  `grep 'root' --color=auto`

* shell全为可变参数列表

  shell对于参数的数量没有明确的要求，你可以不传递任何参数，也可以传递很多参数。
  
  这一特性将导致一个经典问题，什么时候是参数输入的结尾。shell中利用两个字符表示参数输入完毕。一个是`Enter`，而另一个是`;`。所以`;`更明确的意义应该为可变参数的输入结束标记。for循环中为什么需要`;`应该显而易见了。
  
  ```
  for item in item1 item2 item3 ; do
          echo $item
  done
  ```

#### Shell的核心在于字符替换

shell将命令执行过程分为如下过程

1. IO重定向设置`ls > file`、`ls 1>&2 file`、`ls < file`、`ls | cat`

   对于IO重定型，其在执行完设置之后会从命令行移除，并不影响之后命令的解释

   ```shell
   ls 1>&2 -n	# 执行替换前
   ls -n1>&2   # 同样可行
   ls -n 1>&2  # 通常将重定向语句放在最后
   ls -n       # 执行替换之后
   ```

   观察上面的代码可以发现，IO重定向语句并不一定需要空格分隔。他们属于shell保留字符序列，shell最先解释的就是他们并把他们从命令字符中删除。

2. 变量替换

   变量替换可以总结为`$`引起的各种替换。

   `${var}`、`${var:-value}`、`${var:=value}`、`${var:-value}`、`${var:-value}`、`${var:-value}`、`${var:-value}`、`${var:-value}`：替换shell中定义的变量值

   `$(command parament)`：替换为command的标准输出

   `$?`、`$@`、`$*`、`$#`、`$0`、`$?`、`$!`

3. 文件名称扩展

   `file*`、`file[1-4]`、`file?`

#### 命令行的替换规则

1. IO重定向
2. 字符变量替换、字符替换仅发生一次
3. '\ '阻止转义

#### shell的命令搜索顺序

1. Shell 首先检查命令是否为保留字（如for或do）
2. 如果不是保留字，也没有被引用，Shell直接检查别名列表，如果在其中找到匹配的别名，就执行替换操作。如果别名定义以空格结尾，Shell还会尝试对下一个单词执行别名替换。针对替换后的最终结果，再次检查保留字列表，如果不是保留字，继续执行第三步。
3. 针对命令名检查函数列表，如果找到的话，执行其中的同名函数。
4. 检查是否为内建命令（cd pwd）
5. 最后，搜索PATH来定位命令
6. 如果还没找到输出错误提示command not found

